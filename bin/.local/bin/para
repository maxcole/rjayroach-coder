#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'pathname'
require 'ostruct'
require 'set'

# Required gems (excluding stdlib)
required_gems = ['thor']

required_gems.each do |gem_name|
  require gem_name
rescue LoadError
  puts "Installing missing gem: #{gem_name}"
  system("gem install #{gem_name}")
  require gem_name
end

class ParaConfig < OpenStruct
  CONFIG_DIR = Pathname.new('~/.config/para').expand_path

  def self.load
    config_data = {}
    return new(config_data) unless CONFIG_DIR.exist?

    CONFIG_DIR.glob('*.{yaml,yml}').each do |file|
      file_config = YAML.load_file(file)
      deep_merge!(config_data, file_config)
    end

    new(config_data)
  end

  def subdirs
    (self['subdirs'] || Para::DEFAULT_SUBDIRS).to_a
  end

  def para_home
    Pathname.new(self['para_home'] || Para::DEFAULT_PARA_HOME).expand_path
  end

  def active_profile
    self['active_profile']
  end

  def active_subdir
    self['active_subdir']
  end

  def profiles
    self['profiles'] || {}
  end

  def level
    (self['level'] || 'NONE').to_s.upcase
  end

  def self.deep_merge!(target, source)
    source.each do |key, value|
      if target[key].is_a?(Hash) && value.is_a?(Hash)
        deep_merge!(target[key], value)
      else
        target[key] = value
      end
    end
  end
end

class GitCommands < Thor
  def initialize(*args)
    super
    @config = ParaConfig.load
  end

  desc 'status', 'Show git status for all repositories'
  def status
    check_all_repos_status
  end

  desc 'commit', 'Commit changes to all repositories (not implemented)'
  def commit
    puts 'Git commit functionality not yet implemented'
  end

  private

  def check_all_repos_status
    profiles = @config.profiles
    profile_subdirs = @config.subdirs

    if profiles.empty?
      puts 'No profiles configured'
      return
    end

    profiles.each do |profile_name, profile_config|
      profile_subdirs.each do |subdir|
        subdir_config = profile_config[subdir] if profile_config
        next unless subdir_config

        # Check configured repositories
        configured_repos = Set.new
        subdir_config.each do |git_repo, label|
          repo_info = parse_repo_entry(git_repo, label)

          # Try the expected directory name first (may be nested path)
          repo_path = @config.para_home / profile_name / subdir / repo_info[:directory_name]
          actual_dir = repo_info[:directory_name]

          # Fall back to repo name if expected directory doesn't exist
          unless repo_path.exist?
            repo_path = @config.para_home / profile_name / subdir / repo_info[:repo_name]
            actual_dir = repo_info[:repo_name] if repo_path.exist?
          end

          if repo_path.exist?
            configured_repos.add(repo_path.to_s)
            has_changes = check_repo_status(repo_path)
            status_text = has_changes ? 'has uncommitted changes' : 'clean'
            puts "#{profile_name}/#{subdir}/#{actual_dir}: #{status_text}"
          else
            puts "#{profile_name}/#{subdir}/#{repo_info[:directory_name]}: repository not found"
          end
        end

        # Also check for any unconfigured repositories in nested directories
        check_unconfigured_repos(profile_name, subdir, configured_repos)
      end
    end
  end

  def extract_repo_name(git_url)
    git_url.split('/').last.gsub('.git', '')
  end

  def check_repo_status(repo_path)
    Dir.chdir(repo_path) do
      `git status --porcelain 2>/dev/null`.strip != ''
    end
  rescue StandardError
    false
  end

  def check_unconfigured_repos(profile_name, subdir, configured_repos)
    subdir_path = @config.para_home / profile_name / subdir
    return unless subdir_path.exist?

    subdir_path.find do |path|
      next unless path.directory? && (path / '.git').exist?

      next if configured_repos.include?(path.to_s)

      relative_path = path.relative_path_from(subdir_path)
      has_changes = check_repo_status(path)
      status_text = has_changes ? 'has uncommitted changes' : 'clean'
      puts "#{profile_name}/#{subdir}/#{relative_path} (unconfigured): #{status_text}"
    end
  rescue StandardError
    # Ignore errors in directory traversal
  end

  def extract_repo_name(git_url)
    git_url.split('/').last.gsub('.git', '')
  end

  def get_directory_name(git_url, label)
    return label.strip if label && !label.strip.empty?

    extract_repo_name(git_url)
  end

  def parse_repo_entry(key, value)
    # New format: name: repo_url
    # Old format: repo_url: name (for backward compatibility)

    if value.nil? || value.strip.empty?
      # Format: repo_url (no custom name)
      git_url = key
      directory_name = extract_repo_name(git_url)
    elsif key.include?('@') || key.start_with?('http')
      # Old format: repo_url: name (backward compatibility)
      git_url = key
      directory_name = get_directory_name(git_url, value)
    else
      # New format: name: repo_url
      git_url = value
      directory_name = key
    end

    {
      git_url: git_url,
      directory_name: directory_name,
      repo_name: extract_repo_name(git_url)
    }
  end
end

class Para < Thor
  CONFIG_DIR = Pathname.new('~/.config/para').expand_path
  DEFAULT_SUBDIRS = %w[areas projects resources archives].freeze
  DEFAULT_PARA_HOME = '~/para'

  def initialize(*args)
    super
    @config = ParaConfig.load
  end

  desc 'init', 'Initialize PARA directory structure based on configuration'
  def init
    profiles = @config.profiles
    profile_subdirs = @config.subdirs

    profiles.each do |profile_name, profile_config|
      profile_path = @config.para_home / profile_name
      profile_path.mkpath

      profile_subdirs.each do |subdir|
        subdir_path = profile_path / subdir
        subdir_path.mkpath

        subdir_config = profile_config[subdir] if profile_config
        next unless subdir_config

        Dir.chdir(subdir_path) do
          subdir_config.each do |git_repo, label|
            repo_info = parse_repo_entry(git_repo, label)
            repo_path = Pathname.new(repo_info[:directory_name])

            # Create parent directories if nested path
            repo_path.parent.mkpath if repo_path.parent.to_s != '.'

            if repo_info[:directory_name] != repo_info[:repo_name]
              # Custom directory name (possibly nested) - clone with full path
              system("git clone #{git_repo} #{repo_info[:directory_name]}")
            else
              # Default directory name
              system("git clone #{git_repo}")
            end
          end
        end
      end
      puts "Created directory: #{profile_name} with #{profile_subdirs.join(', ')}"
    end
  end

  desc 'list [PROFILE]', 'List profiles or contents of a specific profile'
  def list(profile_name = nil)
    if profile_name
      matched_profile = find_matching_profile(profile_name)
      list_profile_contents(matched_profile) if matched_profile
    else
      list_profiles
    end
  end
  map 'ls' => 'list'

  desc 'config', 'Show configuration values and file locations'
  def config
    show_config
  end

  desc 'git SUBCOMMAND', 'Git operations on all repositories'
  subcommand 'git', GitCommands

  desc 'cd-path [REPO]', '(Internal) Output path to repository or para_home', hide: true
  def cd_path(repo_name = nil)
    if repo_name
      target_path = find_repo_path(repo_name)
      puts target_path if target_path
    else
      puts @config.para_home
    end
  end

  desc 'get-level', '(Internal) Get logging level setting', hide: true
  def get_level
    puts @config.level
  end

  private

  def find_matching_profile(partial_name)
    profiles = @config.profiles
    matches = profiles.keys.select { |name| name.start_with?(partial_name) }

    case matches.size
    when 0
      puts "No profile found matching '#{partial_name}'"
      nil
    when 1
      matches.first
    else
      puts "Multiple profiles match '#{partial_name}':"
      matches.each do |match|
        puts "  #{match}"
      end
      nil
    end
  end

  def list_profiles
    profiles = @config.profiles
    if profiles.empty?
      puts 'No profiles configured'
    else
      puts 'Profiles:'
      profiles.each_key do |profile_name|
        puts "  #{profile_name}"
      end
    end
  end

  def list_profile_contents(profile_name)
    profiles = @config.profiles
    profile_config = profiles[profile_name]

    unless profile_config
      puts "Profile '#{profile_name}' not found"
      return
    end

    puts "Contents of profile '#{profile_name}':"

    # Show only subdirectories that are actually defined in the profile
    defined_subdirs = profile_config.keys.select { |key| profile_config[key].is_a?(Hash) }

    if defined_subdirs.empty?
      puts '  No subdirectories defined in profile'
      return
    end

    defined_subdirs.each do |subdir|
      puts "\n#{subdir.capitalize}:"
      profile_path = @config.para_home / profile_name / subdir

      if profile_path.exist?
        # Show labeled entries if config has them, otherwise discover repositories
        if profile_config[subdir]
          show_nested_entries(profile_config[subdir], profile_path)
        else
          discover_and_show_repos(profile_path)
        end
      else
        puts '  (directory not found)'
      end
    end
  end

  def show_config
    puts "Configuration Directory: #{ParaConfig::CONFIG_DIR}"
    puts

    if ParaConfig::CONFIG_DIR.exist?
      config_files = ParaConfig::CONFIG_DIR.glob('*.{yaml,yml}')
      if config_files.empty?
        puts 'No configuration files found'
      else
        puts 'Configuration Files:'
        config_files.each do |file|
          puts "  #{file}"
        end
      end
    else
      puts 'Configuration directory does not exist'
    end

    puts
    puts 'Loaded Configuration:'
    if @config.to_h.empty?
      puts '  (no configuration loaded)'
    else
      puts @config.to_h.to_yaml
    end
  end

  def find_repo_path(repo_name)
    profiles = @config.profiles

    # If active profile and subdir are set, search there first
    if @config.active_profile && @config.active_subdir
      profile_config = profiles[@config.active_profile]
      if profile_config && profile_config[@config.active_subdir]
        found_path = search_subdir_for_repo(@config.active_profile, @config.active_subdir,
                                            profile_config[@config.active_subdir], repo_name)
        return found_path if found_path
      end
    end

    # Search all profiles and subdirs
    profiles.each do |profile_name, profile_config|
      next unless profile_config

      @config.subdirs.each do |subdir|
        subdir_config = profile_config[subdir]
        next unless subdir_config

        found_path = search_subdir_for_repo(profile_name, subdir, subdir_config, repo_name)
        return found_path if found_path
      end
    end

    nil
  end

  def search_subdir_for_repo(profile_name, subdir, subdir_config, repo_name)
    # First, search through configured repositories
    subdir_config.each do |git_repo, label|
      repo_info = parse_repo_entry(git_repo, label)

      # Check if search term matches either the directory name or repo name
      next unless repo_info[:directory_name].start_with?(repo_name) || repo_info[:repo_name].start_with?(repo_name)

      # Try the expected directory name first (may be nested path)
      repo_path = @config.para_home / profile_name / subdir / repo_info[:directory_name]
      return repo_path.to_s if repo_path.exist?

      # Fall back to the repo name if expected directory doesn't exist
      repo_path = @config.para_home / profile_name / subdir / repo_info[:repo_name]
      return repo_path.to_s if repo_path.exist?
    end

    # Fallback: recursively search for any git repositories in the subdir
    subdir_path = @config.para_home / profile_name / subdir
    if subdir_path.exist?
      found_path = recursive_repo_search(subdir_path, repo_name)
      return found_path if found_path
    end

    nil
  end

  def recursive_repo_search(base_path, repo_name)
    base_path.find do |path|
      next unless path.directory? && path.basename.to_s.start_with?(repo_name)

      # Check if this directory is a git repository
      git_dir = path / '.git'
      return path.to_s if git_dir.exist?
    end
    nil
  rescue StandardError
    nil
  end

  def show_nested_entries(subdir_config, base_path)
    shown_repos = Set.new

    # Show configured repositories
    subdir_config.each do |git_repo, label|
      repo_info = parse_repo_entry(git_repo, label)
      expected_path = base_path / repo_info[:directory_name]
      fallback_path = base_path / repo_info[:repo_name]

      actual_path = nil
      actual_relative = nil

      # Check expected path first, then fallback
      if expected_path.exist? && (expected_path / '.git').exist?
        actual_path = expected_path
        actual_relative = repo_info[:directory_name]
      elsif fallback_path.exist? && (fallback_path / '.git').exist?
        actual_path = fallback_path
        actual_relative = repo_info[:repo_name]
      end

      if actual_path
        shown_repos.add(actual_path.to_s)
        if label && !label.strip.empty? && repo_info[:directory_name] != repo_info[:repo_name]
          puts "  #{actual_relative} → #{repo_info[:directory_name]} (#{repo_info[:repo_name]})"
        else
          puts "  #{actual_relative}"
        end
      else
        puts "  #{repo_info[:directory_name]} (missing)"
      end
    end

    # Show any unconfigured repositories
    discover_unconfigured_repos(base_path, shown_repos)
  end

  def discover_and_show_repos(base_path)
    repos_found = false

    base_path.find do |path|
      next unless path.directory? && (path / '.git').exist?

      relative_path = path.relative_path_from(base_path)
      puts "  #{relative_path} (unconfigured)"
      repos_found = true
    end

    puts '  (empty)' unless repos_found
  rescue StandardError
    puts '  (empty)'
  end

  def discover_unconfigured_repos(base_path, shown_repos)
    base_path.find do |path|
      next unless path.directory? && (path / '.git').exist?

      unless shown_repos.include?(path.to_s)
        relative_path = path.relative_path_from(base_path)
        puts "  #{relative_path} (unconfigured)"
      end
    end
  rescue StandardError
    # Ignore traversal errors
  end

  def extract_repo_name(git_url)
    git_url.split('/').last.gsub('.git', '')
  end

  def get_directory_name(git_url, label)
    return label.strip if label && !label.strip.empty?

    extract_repo_name(git_url)
  end

  def parse_repo_entry(key, value)
    # New format: name: repo_url
    # Old format: repo_url: name (for backward compatibility)

    if value.nil? || value.strip.empty?
      # Format: repo_url (no custom name)
      git_url = key
      directory_name = extract_repo_name(git_url)
    elsif key.include?('@') || key.start_with?('http')
      # Old format: repo_url: name (backward compatibility)
      git_url = key
      directory_name = get_directory_name(git_url, value)
    else
      # New format: name: repo_url
      git_url = value
      directory_name = key
    end

    {
      git_url: git_url,
      directory_name: directory_name,
      repo_name: extract_repo_name(git_url)
    }
  end
end

# Sample Configuration (~/.config/para/config.yaml):
#
# ---
# # Global settings
# active_profile: work
# active_subdir: areas
# para_home: ~/para
# subdirs: [areas, projects, resources, archives]
# level: NONE  # Output level: NONE (silent) or DEBUG (verbose) for 'para cd'
#
# profiles:
#   work:
#     areas:
#       # New format: name: repo_url
#       customer-api: git@github.com:company/customer-service.git
#       user-service: git@github.com:company/user-management.git
#
#       # Nested directories
#       backend/auth: git@github.com:company/auth-service.git
#       frontend/dashboard: git@github.com:company/admin-dashboard.git
#
#       # Simple repo (uses repo name as directory)
#       git@github.com:company/legacy-app.git:
#
#     projects:
#       mobile/ios: git@github.com:company/ios-app.git
#       mobile/android: git@github.com:company/android-app.git
#       web/client: git@github.com:company/web-client.git
#
#     resources:
#       docs: git@github.com:company/documentation.git
#       scripts: git@github.com:company/dev-tools.git
#
#   personal:
#     areas:
#       dotfiles: git@github.com:username/dotfiles.git
#       blog: git@github.com:username/personal-blog.git
#
#     projects:
#       hobby/game: git@github.com:username/game-project.git
#       learning/rust: git@github.com:username/rust-practice.git

Para.start(ARGV)
