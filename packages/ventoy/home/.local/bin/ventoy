#!/usr/bin/env ruby

require 'digest'
require 'fileutils'
require 'net/http'
require 'open3'
require 'thor'
require 'yaml'

class VentoyManager < Thor
  def self.exit_on_failure? = true

  def initialize(*args)
    super
    @config = load_config
    @data_dir = File.expand_path(ENV['XDG_DATA_HOME'] || '~/.local/share') + '/ventoy'
    @cache_dir = File.expand_path(ENV['XDG_CACHE_HOME'] || '~/.cache') + '/ventoy'
    ensure_directories
  end

  desc 'prepare DEVICE', 'Download and install Ventoy to USB device'
  option :force, aliases: '-f', type: :boolean, desc: 'Force installation without confirmation'
  def prepare(device)
    device = validate_device(device)

    # Check if device has an ISO image that needs wiping
    check_and_wipe_iso(device)

    unless options[:force]
      exit unless yes?("WARNING: This will destroy all data on #{device}. Continue?", :red)
    end

    install_dependencies
    download_ventoy
    extract_ventoy
    install_ventoy(device)
  end

  desc 'add-iso DEVICE', 'Download ISOs to Ventoy disk'
  option :mount, aliases: '-m', desc: 'Mount point', default: '/mnt/iso_storage'
  def add_iso(device)
    # Validate device exists
    unless File.exist?(device)
      puts "Error: Device #{device} does not exist"
      exit 1
    end

    mount_device(device, options[:mount])
    @config['iso_files'].each do |iso|
      download_iso(iso, options[:mount])
    end
    unmount_device(options[:mount])
  end

  desc 'list-isos', 'List available ISO configurations'
  def list_isos
    puts "Configured ISOs:"
    @config['iso_files'].each do |iso|
      puts "  - #{iso['name']}: #{iso['url']}"
    end
  end

  desc 'status DEVICE', 'Check Ventoy installation status'
  def status(device)
    if ventoy_installed?(device)
      puts "Ventoy is installed on #{device}"
      show_ventoy_info(device)
    else
      puts "Ventoy is not installed on #{device}"
    end
  end

  desc 'config', 'Manage configuration'
  option :edit, type: :boolean, desc: 'Edit configuration'
  option :show, type: :boolean, desc: 'Show configuration'
  def config
    if options[:edit]
      edit_config
    else
      show_config_info
    end
  end

  no_commands do
    def load_config
    search_paths = [
      './config.yml',
      File.expand_path('~/.config/ventoy/config.yml')
    ]

    config_file = search_paths.find { |path| File.exist?(path) }

    unless config_file
      init_default_config(search_paths.last)
      config_file = search_paths.last
    end

    YAML.load_file(config_file)
  end

  def init_default_config(path)
    FileUtils.mkdir_p(File.dirname(path))
    config = {
      'ventoy' => {
        'version' => 'v1.0.99',
        'dir' => 'ventoy-1.0.99',
        'file' => 'ventoy-1.0.99-linux.tar.gz',
        'checksum' => 'sha256:467cdd188a7f739bc706adbc1d695f61ffdefc95916adb015947d80829f00a3d'
      },
      'iso_files' => [
        {
          'name' => 'debian-13.1.0-amd64-netinst.iso',
          'url' => 'https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-13.1.0-amd64-netinst.iso',
          'checksum' => 'sha256:cc6cc024a9acfcdb7ec5cb9e242e98962dba8b7074a5ac39c7e5f73bc4b98ee2'
        },
        {
          'name' => 'proxmox-ve_8.3-1.iso',
          'url' => 'https://enterprise.proxmox.com/iso/proxmox-ve_8.3-1.iso',
          'checksum' => 'sha256:7007d9e5dea7d52c5e7f1b3a5c81e51bb306fcc2a7b2a4b5f5a74c65b5b1c1b1'
        }
      ]
    }
    File.write(path, config.to_yaml)
    puts "Created default config at #{path}"
  end

  def ensure_directories
    [@data_dir, @cache_dir].each do |dir|
      FileUtils.mkdir_p(dir)
    end
  end


  def validate_device(device)
    unless File.exist?(device)
      puts "Error: Device #{device} does not exist"
      puts "\nAvailable block devices:"
      system("lsblk -o NAME,SIZE,TYPE,MOUNTPOINT | grep -E 'disk|part'")
      exit 1
    end

    unless device.start_with?('/dev/')
      puts "Error: Invalid device path: #{device}"
      puts "Device path must start with /dev/"
      exit 1
    end

    # Check if it's a partition instead of whole disk
    if device =~ /\d+$/
      puts "Warning: #{device} appears to be a partition, not a whole disk"
      base_device = device.gsub(/\d+$/, '')
      unless yes?("Did you mean to use #{base_device} instead?")
        puts "Proceeding with #{device}"
      else
        device = base_device
      end
    end

    # Get device info
    device_info = `lsblk -n -o SIZE,MODEL #{device} 2>/dev/null`.strip
    if device_info.empty?
      puts "Error: Cannot get device info for #{device}"
      exit 1
    end

    puts "\nDevice: #{device}"
    puts "Info: #{device_info}"

    # Check for system disk
    mount_info = `lsblk -n -o MOUNTPOINT #{device} 2>/dev/null`.strip
    if mount_info.include?('/') || mount_info.include?('/boot')
      puts "\n‚ö†Ô∏è  WARNING: This device contains system partitions!"
      unless yes?("Are you ABSOLUTELY SURE you want to continue?", :red)
        exit 1
      end
    end

    device
  end

  def check_and_wipe_iso(device)
    # Check if device contains an ISO image
    blkid_output = `sudo blkid #{device} 2>/dev/null`.strip

    if blkid_output.include?('TYPE="iso9660"')
      iso_label = blkid_output[/LABEL="([^"]*)"/, 1] || "Unknown"
      puts "\nüîç Detected ISO image on #{device}: #{iso_label}"
      puts "This appears to be an ISO image written directly to the device."
      puts "Ventoy installation requires wiping this ISO image first."

      if yes?("Wipe the ISO image and prepare device for Ventoy?", :yellow)
        puts "Wiping device (this may take a moment)..."
        sudo_command("dd if=/dev/zero of=#{device} bs=1M count=100 status=progress")
        puts "‚úì Device wiped successfully"

        # Force kernel to re-read the partition table
        sudo_command("partprobe #{device}")
        sleep 2
      else
        puts "Cannot proceed without wiping the ISO. Exiting."
        exit 1
      end
    end
  end

  def execute_command(cmd)
    stdout, stderr, status = Open3.capture3(cmd)
    unless status.success?
      puts "Command failed: #{cmd}"
      puts stderr
      exit 1
    end
    stdout
  end

  def sudo_command(cmd)
    full_cmd = "sudo #{cmd}"
    puts "Running: #{full_cmd}"
    stdout, stderr, status = Open3.capture3(full_cmd)
    unless status.success?
      puts "Command failed: #{full_cmd}"
      puts stderr
      exit 1
    end
    stdout
  end

  def install_dependencies
    packages = %w[xz-utils fdisk parted dosfstools expect]
    puts "Installing required packages..."
    sudo_command("apt-get update")
    sudo_command("apt-get install -y #{packages.join(' ')}")
  end

  def download_ventoy
    ventoy_file = @config['ventoy']['file']
    ventoy_version = @config['ventoy']['version']
    ventoy_checksum = @config['ventoy']['checksum']
    ventoy_path = "#{@cache_dir}/#{ventoy_file}"

    if File.exist?(ventoy_path)
      print "Verifying existing Ventoy archive..."
      if verify_checksum(ventoy_path, ventoy_checksum)
        puts " OK"
        return
      else
        puts " FAILED"
        File.delete(ventoy_path)
      end
    end

    url = "https://sourceforge.net/projects/ventoy/files/#{ventoy_version}/#{ventoy_file}/download"
    puts "Downloading Ventoy #{ventoy_version}..."
    puts "URL: #{url}"
    download_file_with_progress(url, ventoy_path)

    print "Verifying checksum..."
    unless verify_checksum(ventoy_path, ventoy_checksum)
      puts " FAILED"
      File.delete(ventoy_path)
      puts "Error: Checksum verification failed"
      exit 1
    end
    puts " OK"
  end

  def extract_ventoy
    ventoy_file = @config['ventoy']['file']
    ventoy_dir = @config['ventoy']['dir']
    ventoy_archive = "#{@cache_dir}/#{ventoy_file}"
    extract_dir = @data_dir
    target_dir = "#{extract_dir}/#{ventoy_dir}"

    if File.exist?(target_dir)
      puts "Ventoy already extracted at #{target_dir}"
      return
    end

    unless File.exist?(ventoy_archive)
      puts "Error: Ventoy archive not found at #{ventoy_archive}"
      exit 1
    end

    puts "Extracting Ventoy to #{extract_dir}..."
    execute_command("tar -xzf #{ventoy_archive} -C #{extract_dir}")
    puts "Extraction complete"
  end

  def install_ventoy(device)
    ventoy_dir = @config['ventoy']['dir']
    ventoy_script = "#{@data_dir}/#{ventoy_dir}/Ventoy2Disk.sh"

    unless File.exist?(ventoy_script)
      puts "Error: Ventoy script not found at #{ventoy_script}"
      puts "Please run extraction first"
      exit 1
    end

    puts "\nInstalling Ventoy to #{device}..."
    puts "This will:"
    puts "  - Create 2 partitions on #{device}"
    puts "  - Partition 1: VTOYEFI (FAT) for boot files"
    puts "  - Partition 2: Ventoy (exFAT) for ISO files"

    # Use expect to handle both interactive prompts
    expect_script = <<~EOF
      spawn sudo sh #{ventoy_script} -i #{device}
      expect {
        "Continue? (y/n)" { send "y\\r"; exp_continue }
        "Double-check. Continue? (y/n)" { send "y\\r"; exp_continue }
        eof
      }
    EOF

    puts "Running Ventoy installation..."
    output = `expect -c '#{expect_script}' 2>&1`

    if output.include?("success") || output.include?("done")
      puts "\n‚úì Ventoy installed successfully!"
      # Give system time to update partition table
      sleep 2
      system("sudo partprobe #{device}")

      # Fix partition bootable flags - EFI partition should be bootable, not the data partition
      puts "Fixing partition bootable flags..."
      fix_partition_flags(device)

      show_ventoy_info(device)
    else
      puts "\nInstallation output:"
      puts output
    end
  end

  def download_file(url, dest)
    uri = URI(url)
    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|
      request = Net::HTTP::Get.new(uri)
      http.request(request) do |response|
        File.open(dest, 'wb') do |file|
          response.read_body do |chunk|
            file.write(chunk)
          end
        end
      end
    end
  end

  def download_file_with_progress(url, dest)
    uri = URI(url)
    temp_file = "#{dest}.tmp"

    Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == 'https') do |http|
      request = Net::HTTP::Get.new(uri)
      http.request(request) do |response|
        if response.code == '302' || response.code == '301'
          redirect_url = response['location']
          puts "Following redirect to: #{redirect_url}"
          download_file_with_progress(redirect_url, dest)
          return
        end

        unless response.code == '200'
          puts "Error: HTTP #{response.code} - #{response.message}"
          exit 1
        end

        total = response['content-length'].to_i
        downloaded = 0

        File.open(temp_file, 'wb') do |file|
          response.read_body do |chunk|
            file.write(chunk)
            downloaded += chunk.size
            if total > 0
              percent = (downloaded.to_f / total * 100).round(2)
              print "\rProgress: #{percent}% (#{downloaded}/#{total} bytes)"
            else
              print "\rDownloaded: #{downloaded} bytes"
            end
          end
        end
        puts
      end
    end

    FileUtils.mv(temp_file, dest)
  rescue => e
    File.delete(temp_file) if File.exist?(temp_file)
    puts "Download failed: #{e.message}"
    exit 1
  end

  def verify_checksum(file, expected)
    return false unless File.exist?(file)
    algo, hash = expected.split(':')
    actual = case algo
             when 'sha256' then Digest::SHA256.file(file).hexdigest
             when 'md5' then Digest::MD5.file(file).hexdigest
             else return false
             end
    actual == hash
  end

  def mount_device(device, mount_point)
    sudo_command("mkdir -p #{mount_point}")

    if mounted?(mount_point)
      puts "Device already mounted at #{mount_point}"
      return
    end

    unless File.exist?(device)
      puts "Error: Device #{device} does not exist"
      exit 1
    end

    puts "Mounting #{device} to #{mount_point}..."

    # Try exfat first with rw option
    output, stderr, status = Open3.capture3("sudo mount -t exfat -o rw,uid=#{Process.uid},gid=#{Process.gid} #{device} #{mount_point}")
    unless status.success?
      puts "ExFAT mount failed, trying auto-detect with rw..."
      output, stderr, status = Open3.capture3("sudo mount -o rw,uid=#{Process.uid},gid=#{Process.gid} #{device} #{mount_point}")
      unless status.success?
        puts "Mount failed. Checking if partition needs formatting..."

        # Check filesystem type
        fs_check = `sudo file -s #{device} 2>/dev/null`
        puts "Filesystem info: #{fs_check}"

        if fs_check.include?("data") || fs_check.include?("empty")
          puts "Partition appears unformatted. Formatting as exFAT..."
          sudo_command("mkfs.exfat #{device}")

          # Try mounting again after formatting
          output, stderr, status = Open3.capture3("sudo mount -t exfat -o rw,uid=#{Process.uid},gid=#{Process.gid} #{device} #{mount_point}")
          unless status.success?
            puts "Error mounting device after formatting: #{stderr}"
            exit 1
          end
        else
          puts "Error mounting device: #{stderr}"
          exit 1
        end
      end
    end

    # Verify the mount is writable
    test_file = "#{mount_point}/.write_test"
    unless system("touch #{test_file} 2>/dev/null && rm -f #{test_file} 2>/dev/null")
      puts "Warning: Mount point appears to be read-only"

      # Try remounting with proper permissions
      sudo_command("umount #{mount_point}")
      output, stderr, status = Open3.capture3("sudo mount -t exfat -o rw,uid=#{Process.uid},gid=#{Process.gid},umask=0000 #{device} #{mount_point}")
      unless status.success?
        puts "Error: Cannot mount device as writable: #{stderr}"
        exit 1
      end
    end

    puts "‚úì Mounted successfully as read-write"
  end

  def unmount_device(mount_point)
    unless mounted?(mount_point)
      puts "Device not mounted at #{mount_point}"
      return
    end

    puts "Unmounting #{mount_point}..."
    sudo_command("sync")  # Ensure all writes are flushed
    sudo_command("umount #{mount_point}")
    puts "‚úì Unmounted successfully"
  end

  def mounted?(mount_point)
    system("mountpoint -q #{mount_point}")
  end

  def download_iso(iso_info, dest_dir)
    filename = iso_info['name']
    url = iso_info['url']
    dest_path = "#{dest_dir}/#{filename}"

    # Check if file exists and verify checksum if provided
    if File.exist?(dest_path)
      file_size = File.size(dest_path)
      if iso_info['checksum']
        print "Verifying existing #{filename}..."
        if verify_checksum(dest_path, iso_info['checksum'])
          puts " OK (#{file_size / 1024 / 1024} MB)"
          return
        else
          puts " FAILED - re-downloading"
          File.delete(dest_path)
        end
      else
        puts "#{filename} already exists (#{file_size / 1024 / 1024} MB), skipping..."
        return
      end
    end

    puts "\nDownloading ISO: #{filename}"
    puts "URL: #{url}"
    puts "Destination: #{dest_path}"

    download_file_with_progress(url, dest_path)

    # Always verify checksum if provided
    if iso_info['checksum']
      print "Verifying ISO checksum..."
      if verify_checksum(dest_path, iso_info['checksum'])
        puts " OK"
      else
        puts " FAILED"
        File.delete(dest_path)
        puts "Error: ISO checksum verification failed"
        exit 1
      end
    else
      puts "Warning: No checksum provided for #{filename} - cannot verify integrity"
    end

    file_size = File.size(dest_path)
    puts "‚úì Downloaded #{filename} (#{file_size / 1024 / 1024} MB)"
  end

  def edit_config
    config_paths = [
      './config.yml',
      File.expand_path('~/.config/ventoy/config.yml')
    ]
    config_file = config_paths.find { |path| File.exist?(path) } || config_paths.last
    editor = ENV['EDITOR'] || 'nano'
    system("#{editor} #{config_file}")
  end

  def show_config_info
    config_paths = [
      './config.yml',
      File.expand_path('~/.config/ventoy/config.yml')
    ]
    config_file = config_paths.find { |path| File.exist?(path) }

    puts "Configuration file: #{config_file || 'Not found (will create default)'}"
    puts "Data directory: #{@data_dir}"
    puts "Cache directory: #{@cache_dir}"
    puts "\nVentoy version: #{@config['ventoy']['version']}"
    puts "ISO count: #{@config['iso_files'].size}"
  end

  def ventoy_installed?(device)
    base_device = device.gsub(/\d+$/, '')
    output = `sudo fdisk -l #{base_device} 2>/dev/null`
    output.include?('VTOYEFI')
  end

  def fix_partition_flags(device)
    base_device = device.gsub(/\d+$/, '')

    # Set bootable flag on partition 2 (EFI partition) and remove from others
    puts "  Setting bootable flag on EFI partition..."
    sudo_command("sfdisk -A #{base_device} 2")

    # Update partition table
    sudo_command("partprobe #{base_device}")
    sleep 1

    puts "‚úì Partition flags fixed - EFI partition is now bootable"
  end

  def show_ventoy_info(device)
    base_device = device.gsub(/\d+$/, '')
    puts `sudo fdisk -l #{base_device} 2>/dev/null | grep -E '(Disk|VTOYEFI|exfat)'`
  end
  end
end

VentoyManager.start(ARGV) if __FILE__ == $0
