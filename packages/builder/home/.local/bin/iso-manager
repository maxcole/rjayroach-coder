#!/usr/bin/env ruby
require 'thor'
require 'yaml'
require 'pathname'
require 'digest'
require 'net/http'
require 'uri'
require 'openssl'

class IsoManagerCLI < Thor
  def initialize(*args)
    super
    @manager = IsoManager.new
  end

  desc 'list', 'Display all ISOs in catalog with their status'
  def list
    @manager.list
  end

  desc 'download ISO_KEY', 'Download a specific ISO from catalog'
  option :all, type: :boolean, desc: 'Download all missing ISOs'
  def download(iso_key = nil)
    if options[:all]
      @manager.download_all
    elsif iso_key
      @manager.download(iso_key)
    else
      puts 'Error: Provide an ISO key or use --all flag'
      exit 1
    end
  end

  desc 'verify ISO_KEY', 'Verify checksum of a downloaded ISO'
  option :all, type: :boolean, desc: 'Verify all downloaded ISOs'
  def verify(iso_key = nil)
    if options[:all]
      @manager.verify_all
    elsif iso_key
      @manager.verify(iso_key)
    else
      puts 'Error: Provide an ISO key or use --all flag'
      exit 1
    end
  end

  desc 'add', 'Add a new ISO to the catalog interactively'
  def add
    @manager.add
  end

  desc 'status', 'Show overview of catalog and current directory'
  def status
    @manager.status
  end
end

class IsoManager
  CONFIG_PATH = Pathname.new(Dir.home).join('.config/builder/iso.yml')

  def initialize
    ensure_config_exists
    ensure_iso_dir_exists
  end

  def list
    config = load_config
    isos = config['isos'] || {}

    if isos.empty?
      puts "ISO Catalog (#{CONFIG_PATH})"
      puts
      puts 'No ISOs in catalog. Use "iso-manager add" to add some.'
      return
    end

    puts "ISO Catalog (#{CONFIG_PATH})"
    puts

    downloaded_count = 0
    missing_count = 0

    isos.keys.sort.each do |key|
      iso = isos[key]
      status = file_exists?(iso['filename']) ? '[Downloaded]' : '[Missing]'
      downloaded_count += 1 if status == '[Downloaded]'
      missing_count += 1 if status == '[Missing]'

      puts "#{key.ljust(30)} #{status.ljust(13)} #{iso['name']}"
    end

    puts
    puts "Total: #{isos.size} ISOs (#{downloaded_count} downloaded, #{missing_count} missing)"
  end

  def download(key, force: false)
    config = load_config
    isos = config['isos'] || {}

    unless isos[key]
      puts "Error: ISO '#{key}' not found in catalog"
      exit 1
    end

    iso = isos[key]
    filepath = iso_dir / iso['filename']

    if filepath.exist? && !force
      print "File exists. Re-download? (y/N) "
      response = $stdin.gets.chomp
      return unless response.downcase == 'y'
    end

    puts "Downloading #{iso['filename']}..."
    download_file(iso['url'], filepath)
    puts

    puts 'Verifying checksum...'
    verify(key, silent: false)
  end

  def download_all
    config = load_config
    isos = config['isos'] || {}

    missing = isos.select { |key, iso| !file_exists?(iso['filename']) }

    if missing.empty?
      puts 'All ISOs are already downloaded.'
      return
    end

    puts "Downloading missing ISOs...\n\n"

    success_count = 0
    missing.each.with_index(1) do |(key, iso), idx|
      puts "[#{idx}/#{missing.size}] Downloading #{key}..."
      filepath = iso_dir / iso['filename']

      download_file(iso['url'], filepath)

      if verify(key, silent: true)
        puts "✓ Downloaded and verified\n\n"
        success_count += 1
      else
        puts "✗ Checksum verification failed\n\n"
      end
    end

    puts "Summary: #{success_count} ISOs downloaded successfully"
  end

  def verify(key, silent: false)
    config = load_config
    isos = config['isos'] || {}

    unless isos[key]
      puts "Error: ISO '#{key}' not found in catalog"
      exit 1
    end

    iso = isos[key]
    filepath = iso_dir / iso['filename']

    unless filepath.exist?
      puts "Error: File '#{iso['filename']}' not found in #{iso_dir}" unless silent
      return false
    end

    puts "Verifying #{iso['filename']}..." unless silent

    actual_checksum = calculate_checksum(filepath)
    expected_checksum = iso['checksum'].sub('sha256:', '')

    if actual_checksum == expected_checksum
      puts "✓ Checksum matches: sha256:#{actual_checksum[0..15]}..." unless silent
      true
    else
      puts "✗ Checksum mismatch!" unless silent
      puts "  Expected: sha256:#{expected_checksum[0..15]}..." unless silent
      puts "  Got:      sha256:#{actual_checksum[0..15]}..." unless silent
      false
    end
  end

  def verify_all
    config = load_config
    isos = config['isos'] || {}

    downloaded = isos.select { |key, iso| file_exists?(iso['filename']) }

    if downloaded.empty?
      puts 'No downloaded ISOs to verify.'
      return
    end

    puts "Verifying downloaded ISOs...\n\n"

    passed = 0
    failed = 0

    downloaded.each do |key, iso|
      result = verify(key, silent: true)
      status = result ? '✓' : '✗ Checksum mismatch'
      puts "#{iso['filename'].ljust(35)} #{status}"

      result ? passed += 1 : failed += 1
    end

    puts
    puts "Summary: #{passed} passed, #{failed} failed"
  end

  def add
    puts "Add New ISO to Catalog\n\n"

    print 'ISO URL: '
    url = $stdin.gets.chomp

    unless url.start_with?('http://', 'https://')
      puts 'Error: URL must start with http:// or https://'
      exit 1
    end

    print 'Checksum (hash or URL): '
    checksum_input = $stdin.gets.chomp

    puts "\nProcessing..."

    attributes = derive_attributes(url, checksum_input)

    key = attributes[:filename].sub(/\.iso$/, '')

    puts "\nAdding to catalog as: #{key}\n\n"
    puts "name: #{attributes[:name]}"
    puts "url: #{attributes[:url]}"
    puts "checksum: #{attributes[:checksum]}"
    puts "checksum_url: #{attributes[:checksum_url]}" if attributes[:checksum_url]
    puts "filename: #{attributes[:filename]}"
    puts "architecture: #{attributes[:architecture]}"
    puts "tags: #{attributes[:tags]}"

    config = load_config
    config['isos'] ||= {}
    config['isos'][key] = {
      'name' => attributes[:name],
      'url' => attributes[:url],
      'checksum' => attributes[:checksum],
      'checksum_url' => attributes[:checksum_url],
      'filename' => attributes[:filename],
      'architecture' => attributes[:architecture],
      'tags' => attributes[:tags]
    }.compact

    save_config(config)

    puts "\n✓ Added to catalog"
  end

  def status
    config = load_config
    isos = config['isos'] || {}

    puts "ISO Manager Status\n\n"
    puts "Config: #{CONFIG_PATH}"
    puts "ISO Directory: #{iso_dir}\n\n"

    downloaded = isos.select { |key, iso| file_exists?(iso['filename']) }
    missing = isos.size - downloaded.size

    puts "Catalog Summary:"
    puts "  Total ISOs: #{isos.size}"
    puts "  Downloaded: #{downloaded.size}"
    puts "  Missing: #{missing}\n\n"

    if downloaded.any?
      puts "Disk Usage:"
      total_bytes = 0

      downloaded.each do |key, iso|
        filepath = iso_dir / iso['filename']
        size = filepath.size
        total_bytes += size
        puts "  #{iso['filename'].ljust(35)} #{format_bytes(size)}"
      end

      puts "  #{'Total:'.ljust(35)} #{format_bytes(total_bytes)}"
    end
  end

  private

  def load_config
    return { 'isos' => {} } unless CONFIG_PATH.exist?
    YAML.load_file(CONFIG_PATH) || { 'isos' => {} }
  end

  def save_config(config)
    CONFIG_PATH.write(YAML.dump(config))
  end

  def ensure_config_exists
    return if CONFIG_PATH.exist?
    CONFIG_PATH.dirname.mkpath
    CONFIG_PATH.write(YAML.dump({ 'isos' => {} }))
  end

  def ensure_iso_dir_exists
    iso_dir.mkpath unless iso_dir.exist?
  end

  def iso_dir
    config = load_config
    dir_path = config['iso_dir']

    unless dir_path
      puts "Error: 'iso_dir' not configured in #{CONFIG_PATH}"
      puts "Please add the following to your config file:"
      puts
      puts "iso_dir: /path/to/iso/storage"
      puts "isos:"
      puts "  ..."
      exit 1
    end
    dir_path.gsub!('$HOME', Dir.home)

    Pathname.new(File.expand_path(dir_path))
  end

  def derive_attributes(url, checksum_input)
    uri = URI.parse(url)
    filename = uri.path.split('/').last

    unless filename.end_with?('.iso')
      puts 'Error: Filename must end with .iso'
      exit 1
    end

    puts "  ✓ Extracted filename: #{filename}"

    # Derive name
    name = filename.sub(/\.iso$/, '').gsub(/[-_]/, ' ').split.map(&:capitalize).join(' ')

    # Detect architecture
    arch_patterns = {
      'amd64' => /amd64/i,
      'x86_64' => /x86[-_]?64/i,
      'arm64' => /arm64/i,
      'aarch64' => /aarch64/i,
      'i386' => /i386/i,
      'x86' => /\bx86\b/i,
      'armhf' => /armhf/i
    }

    architecture = 'unknown'
    arch_patterns.each do |arch, pattern|
      if filename.match?(pattern)
        architecture = arch
        break
      end
    end

    puts "  ✓ Detected architecture: #{architecture}"

    # Handle checksum
    checksum = nil
    checksum_url = nil

    if checksum_input.start_with?('http://', 'https://')
      checksum_url = checksum_input
      puts "  ✓ Downloading checksum file..."
      checksum = download_checksum_file(checksum_url, filename)
      puts "  ✓ Extracted checksum: #{checksum}"
    else
      if checksum_input.match?(/^[a-f0-9]{64}$/i)
        checksum = "sha256:#{checksum_input}"
      elsif checksum_input.start_with?('sha256:')
        checksum = checksum_input
      else
        puts 'Error: Checksum must be 64 hex characters or start with sha256:'
        exit 1
      end
    end

    {
      name: name,
      url: url,
      checksum: checksum,
      checksum_url: checksum_url,
      filename: filename,
      architecture: architecture,
      tags: []
    }
  end

  def download_file(url, destination, redirect_limit = 5)
    raise 'Too many redirects' if redirect_limit == 0

    uri = URI.parse(url)

    http = Net::HTTP.new(uri.host, uri.port)
    if uri.scheme == 'https'
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end

    http.start do
      request = Net::HTTP::Get.new(uri.request_uri)

      http.request(request) do |response|
        case response
        when Net::HTTPRedirection
          return download_file(response['location'], destination, redirect_limit - 1)
        when Net::HTTPSuccess
          total_size = response['content-length'].to_i
          downloaded = 0

          File.open(destination, 'wb') do |file|
            response.read_body do |chunk|
              file.write(chunk)
              downloaded += chunk.size

              if total_size > 0
                percentage = (downloaded.to_f / total_size * 100).round(1)
                print "\rProgress: #{format_bytes(downloaded)} / #{format_bytes(total_size)} (#{percentage}%)"
              else
                print "\rDownloaded: #{format_bytes(downloaded)}"
              end
            end
          end
        else
          raise "HTTP Error: #{response.code} #{response.message}"
        end
      end
    end
  end

  def calculate_checksum(filepath)
    Digest::SHA256.file(filepath).hexdigest
  end

  def download_checksum_file(url, filename)
    uri = URI.parse(url)

    http = Net::HTTP.new(uri.host, uri.port)
    if uri.scheme == 'https'
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    end

    response = http.get(uri.request_uri)

    unless response.is_a?(Net::HTTPSuccess)
      puts "Error: Failed to download checksum file"
      exit 1
    end

    content = response.body

    # Parse checksum file to find matching filename
    content.each_line do |line|
      parts = line.strip.split(/\s+/)
      next if parts.size < 2

      hash = parts[0]
      file = parts[-1].sub(/^\*/, '')  # Remove asterisk if present

      if file == filename
        return "sha256:#{hash}"
      end
    end

    puts "Error: Could not find checksum for #{filename} in checksum file"
    exit 1
  end

  def file_exists?(filename) = (iso_dir / filename).exist?

  def format_bytes(bytes)
    units = ['B', 'KB', 'MB', 'GB', 'TB']
    return "0 B" if bytes == 0

    exp = (Math.log(bytes) / Math.log(1024)).floor
    exp = [exp, units.size - 1].min

    "%.2f %s" % [bytes.to_f / (1024 ** exp), units[exp]]
  end
end

IsoManagerCLI.start(ARGV)
